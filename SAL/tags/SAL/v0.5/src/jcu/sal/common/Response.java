package jcu.sal.common;

import java.io.Serializable;
import java.nio.channels.ClosedChannelException;

import javax.naming.ConfigurationException;

public class Response implements Serializable {
	private static final long serialVersionUID = -4090794353146528167L;
	private byte[] b;
	private String sid;
	private boolean error;
	private long timeStamp;
	
	public Response(byte[] bb, String sid) {
		timeStamp = System.currentTimeMillis();
		this.sid = sid;
		error = false;
		if(bb==null)
			b= new byte[0];
		else
			b = bb;
	}
	
	/**
	 * This constructor builds a response object with either the errror or the end flag set. It is only intended to be used
	 * by streaming threads returning a response via a callback method 
	 * @param sid the sensor id
	 * @param e whether there was an error or not (normal end of stream)
	 */
	public Response(String sid, boolean e){
		this(null,sid);
		b=null;
		error = e;
	}
	
	/**
	 * This method returns the sensor identifier of the sensor which generated the response
	 * @return the sensor identifier of the sensor which generated the response
	 */
	public String getSID() {
		return sid;
	}
	
	/**
	 * This method returns the raw data from the sensor as a byte array.
	 * @return the raw data from the sensor 
	 * @throws ConfigurationException if there was an error getting the raw data at the sensor
	 * @throws ClosedChannelException if the streaming channel has been closed by the sensor
	 */
	public byte[] getBytes() throws ConfigurationException, ClosedChannelException {
		if(b==null && error)
			throw new ConfigurationException();
		else if(b==null && !error)
			throw new ClosedChannelException();
		return b;
	}
	
	/**
	 * This method returns the length of the raw data from the sensor.
	 * @return the raw data from the sensor 
	 * @throws ConfigurationException if there was an error getting the raw data at the sensor
	 * @throws ClosedChannelException if the streaming channel has been closed by the sensor
	 */
	public int getLength() throws ConfigurationException, ClosedChannelException{
		return getBytes().length;
	}
	
	/**
	 * This method returns the raw data from the sensor as a string
	 * @return the raw data from the sensor as a string
	 * @throws ConfigurationException if there was an error getting the raw data at the sensor
	 * @throws ClosedChannelException if the streaming channel has been closed by the sensor
	 */
	public String getString() throws ConfigurationException, ClosedChannelException {
		return new String(getBytes());
	}
	
	/**
	 * This method returns the raw data from the sensor as an integer
	 * @return the raw data from the sensor as an integer
	 * @throws ConfigurationException if there was an error getting the raw data at the sensor
	 * @throws ClosedChannelException if the streaming channel has been closed by the sensor
	 */
	public int getInt() throws ConfigurationException, ClosedChannelException {
		return Integer.parseInt(getString());
	}
	
	/**
	 * This method returns the raw data from the sensor as a float.
	 * @return the raw data from the sensor as a float.
	 * @throws ConfigurationException if there was an error getting the raw data at the sensor
	 * @throws ClosedChannelException if the streaming channel has been closed by the sensor
	 */
	public float getFloat() throws ConfigurationException, ClosedChannelException {
		return Float.parseFloat(getString());
	}
	
	/**
	 * This method returns a timestamp (generated by the SAL agent) at which the reading was generated.  
	 * @return a UNIX timestamp (number of milliseconds elapsed since 1 Jan 1970)
	 */
	public long getTimeStamp(){
		return timeStamp;
	}
}
