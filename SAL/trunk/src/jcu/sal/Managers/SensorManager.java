/**
 * 
 */
package jcu.sal.Managers;

import java.text.ParseException;
import java.util.Arrays;
import java.util.Enumeration;

import javax.naming.ConfigurationException;
import javax.xml.parsers.ParserConfigurationException;

import jcu.sal.Components.Identifiers.Identifier;
import jcu.sal.Components.Identifiers.SensorID;
import jcu.sal.Components.Sensors.Sensor;
import jcu.sal.utils.Slog;
import jcu.sal.utils.XMLhelper;

import org.apache.log4j.Logger;
import org.w3c.dom.Node;


/**
 * @author gilles
 * 
 */
public class SensorManager extends ManagerFactory<Sensor> implements Runnable{
	
	/**
	 * The following string must be used in partially generated SML
	 * docs (like the ones autogenerated when a new sensor is detected).
	 * The marker will be replaced by an appropriate sensor ID when
	 * a sensor object is created.
	 */
	public static String SENSORID_MARKER="%AUTOSENSORID%";
	
	/**
	 * specifies (in seconds) how long disconnected sensors should remain before being
	 * deleted
	 */
	public static long DISCONNECT_TIMEOUT = 20;
	private Thread sensor_removal;
	
	/**
	 * specifies (in seconds) how often the sensor removal thread kick in
	 */
	public static int REMOVE_SENSOR_INTERVAL = 0;
	
	private static SensorManager s = new SensorManager();
	private Logger logger = Logger.getLogger(SensorManager.class);
	
	
	/**
	 * Private constructor
	 */
	private SensorManager() {
		super();
		Slog.setupLogger(this.logger);
		sensor_removal = new Thread(this, "sensor_manager_thread");
	}
	
	/**
	 * Returns the instance of the SensorManager 
	 * @return
	 */
	static SensorManager getSensorManager() {
		return s;
	}

	/* (non-Javadoc)
	 * @see jcu.sal.Managers.ManagerFactory#build(org.w3c.dom.Document)
	 */
	@Override
	protected Sensor build(Node n) throws InstantiationException {
		SensorID i = null;
		Sensor sensor = null;
		
		this.logger.debug("building Sensor");
		try {
			i = (SensorID) this.getComponentID(n);
			this.logger.debug("Component type: " + getComponentType(n));
			sensor = new Sensor(i, getComponentConfig(n));
		} catch (ParseException e) {
			this.logger.error("Error while parsing the DOM document. XML doc:");
			this.logger.error(XMLhelper.toString(n));
			//e.printStackTrace();
			throw new InstantiationException();
		} catch (ConfigurationException e) {
			this.logger.error("Couldnt instanciate the sensor: " + i.toString());
			//e.printStackTrace();
			throw new InstantiationException();
		} 
		return sensor;
	}
	
	/* (non-Javadoc)
	 * @see jcu.sal.Managers.ManagerFactory#getComponentID(org.w3c.dom.Document)
	 */
	@Override
	protected Identifier getComponentID(Node n) throws ParseException {
		Identifier id = null;
		try {
			id = new SensorID(XMLhelper.getAttributeFromName("//" + Sensor.SENSOR_TAG, Sensor.SENSORID_TAG, n) );
			logger.debug("Sensor id: " + id.toString());
		} catch (Exception e) {
			logger.error("Couldnt find the Sensor id");
			e.printStackTrace();
			throw new ParseException("Couldnt create the Sensor identifier", 0);
		}
		return id;
	}
	
	/* (non-Javadoc)
	 * @see jcu.sal.Managers.ManagerFactory#remove(java.lang.Object)
	 */
	@Override
	protected void remove(Sensor component) {
		component.remove(this);
	}
	
	
	Sensor createSensorFromPartialSML(String s) {
		Sensor ss = null;
		try {
			synchronized(this) {
				String t = s.replace(SENSORID_MARKER, generateNewSensorID());
				Node n = XMLhelper.createDocument(t);
				ss = createComponent(n);
			}
		} catch (ConfigurationException e) {
			logger.error("new sensor creation failed");
		} catch (ParserConfigurationException e) {
			logger.error("Cant create the new sensor, incorrect SML document");
		}
		return ss;
	}
	
	/**
	 * Returns the first available unused sensor ID
	 * @return the first available unused sensor ID
	 */
	private String generateNewSensorID() {
		int[] arr = new int[getSize()];
		Enumeration<Identifier> e = getKeys();
		int i=0;
		while(e.hasMoreElements()){
			arr[i++] = Integer.parseInt(e.nextElement().getName());
		}
		Arrays.sort(arr);
		if(arr[0]==1) {
			for (i = 1; i < arr.length; i++) {
				if(arr[i]>(arr[i-1]+1)) {
					break;
				}
			}
			i=arr[i-1]+1;
		} else i=1;
		
		return String.valueOf(i);
	}
	
	@Override
	protected String getComponentType(Node n) throws ParseException {
		return Sensor.SENSOR_TYPE;
	}
	
	public void stop(){
		sensor_removal.interrupt();
	}
	public void start() {
		if(REMOVE_SENSOR_INTERVAL!=0)
			sensor_removal.start();
	}
	
	/**
	 * This method runs as a spearate thread and deletes sensors which
	 * have been disconnected for too long
	 *
	 */
	public void run() {
		Sensor s;
		long diff, disc_ts;
		logger.debug("Starting sensor removal thread");
		try { 
		while(!Thread.interrupted()){
			Enumeration<Identifier> e  = getKeys();
			while(e.hasMoreElements() && !Thread.interrupted()) {
				synchronized(this) {
					s = getComponent(e.nextElement());
					disc_ts = s.getDisconnectTimestamp();
					if(s!=null && disc_ts!=-1) {
						diff = System.currentTimeMillis() - disc_ts;
						if(diff > (DISCONNECT_TIMEOUT*1000)) {
							logger.debug("About to remove sensor " + s.toString()+ " disconnect timeout expired (diff="+diff+")");
							ProtocolManager.getProcotolManager().removeSensor(s);
						}
					}
				}
			}
			Thread.sleep(REMOVE_SENSOR_INTERVAL*1000);
		}
		} catch (InterruptedException e1) {}
		logger.debug("Exiting sensor removal thread");
	}

}
